# 多线程处理
进程：

## 任务管理器：
用来管理系统中所有进程；
### 任务管理器一共包含了5个可以切换的TAB页，它们有：
- 应用程序页，进程页，性能页，联网页和用户页。

在进程页中，有一个表格，这个表格一共有四页，它们分别是`映像名称、用户名、CPU、内存使用`；  
这个表格中的每一行数据，都是一个进程，也就是说一个进程有四个属性，当然这四个属性都是Windows赋予的，  
##### 映像名称：即这个进程的名字是什么；
##### 用户名：是说这个进程属于哪个用户；
比如：SYSTEM,就是说这个进程是属于系统的，也就是系统进程；   
而有些进程是属于某一个用户的，而在映像名称这一列，可以看到，这些进程，大部分都是以`“.exe”`为后缀的，  
`“.exe”`是一个可执行文件的后缀名。

### 进程：
每一个进程都对应了操作系统当中应用程序的一个执行实例，
#### 进程的定义：
- 进程就是应用程序的执行实例；
- 当一个应用程序没有执行的时候，它不是一个进程；
- 只有当这个应用程序执行的时候，它才成为一个进程；

#### 进程的特征：
当我们启动一个应用程序的时候，操作系统就会创建一个进程，并且给这个进程分配相应的资源，所以说，进程是具有动态性的。即，进程是动态产生、并且动态消亡的。  
我们可以同时运行多个应用程序，让它们各自完成不同的任务，所以说：进程是具有并发性的；  
系统中的所有进程都可以与其他进程一起并发执行，**注意：并发性，并不是说处理器在某一个时刻，可以同时处理多个应用程序，当一台电脑，只有一个CPU的时候，它在某一个给定的时刻，只能处理一个应用程序**。我们所说的并发性，就是操作系统利用时间片轮转，或者其他的策略，让多个应用程序交替执行的特性；  
如果一个操作系统不支持多进程并发执行的话，那么这个缺点对于操作系统来说将是致命的；

#### 进程的独立性：
进程都是独立运行的，进程是一个独立运行的基本单位，同时也是系统分配资源和进行调度的独立单位；
### 线程：
当启动迅雷时，系统就会创建一个进程--迅雷，  
像迅雷中的下载任务这样，可以作为一个进程内部的执行单元，并完成一个独立的任务，这样的顺序控制流程就称之为线程；

#### 线程定义：
进程内部的一个执行单元，它是程序中一个单一的顺序控制流程；  
如果在一个进程中同时运行了多个线程，用来完成不同的工作，就称之为多线程。
##### 线程的特点：
首先，线程是进程内部的一个执行单元，在同一个进程当中可以包含多个线程，而且在这个进程的所有线程当中，有一个线程比较特殊，我们称之为主线程，主线程就是一个进程的入口，所以说一个进程至少包含一个线程，那就是主线程，在主线程的基础上，一个进程还可以包含若干个其他的线程。但是一个线程不可以离开进程而独立存在，所以：  
一个进程可以包含多个线程；一个线程必须至少要有一个父进程；

其次，一个线程可以独立完成某一个功能，那么在完成这些功能的时候，它就可能定义一些局部变量或者程序计数器,一个线程就可以定义自己的程序计数器和局部变量；  
虽然线程是属于一个进程的，但是线程却可以拥有自己的堆栈、程序计数器和局部变量。

在我们启动一个进程的时候，操作系统会为这个进程分配相应的资源，比方说内存，处理器等，但是我们在一个进程当中启动一个线程的时候，线程不会占用进程之外的这些资源。因为进程才是操作系统分调配资源和进行调度的独立单位，因此，进程当中的线程不会再额外占用进程之外的系统资源了，而是与父进程的其他线程共享进程所有的全部资源；

```
线程独立运行，采用抢占方式；

一个线程可以创建和删除另一个线程；

同一个进程中的多个进程之间可以并发执行；

线程的调度管理是由进程来完成的；
```
**注意**：
编程时，必须确保线程不会妨碍同一进程的其他线程；

##### 线程的分类：
- 系统级线程：  
又称为核心级线程，负责管理调度不同进程之间的多个线程，由操作系统直接管理；

- 用户级线程：  
仅存在于用户空间，在应用程序中控制其创建、执行和消亡；  
多线程开发的优势：  
多线程能够改善用户的体验；  
多线程程序可以极大限度的提高计算机系统的利用效率；


##### 线程的使用步骤：
1.定义一个线程  
2.创建线程的实例  
3.启动线程  
4.终止线程

##### 主线程：
它是在程序开始运行的时候创建的；  
比如：`Java`程序当中的`public static void main`方法；  
它就是主线程的入口；

而我们要创建的“线程”就是除了主线程之外的另外的线程，而不是指的主线程；   
我们编程当中的线程一般来讲都是除了主线程之外的其他线程，而不是主线程；



##### 在Java语言当中如何去创建一个线程：
在`Java`语言当中，我们要创建的所有的线程都是`java.lang.Thread`类或者其子类的一个实例；  
即如果在开发程序的过程当中要创建3个线程，那么就需要3个这样的实例。  
要创建一个线程，首先要定义一个线程。

##### 为什么要定义线程类：
为什么不直接`new`一个`Thread`对象出来而要定义一个线程类？
- 在java.lang.Thread类中：  
有一个`run()`方法，这个方法当中的代码就是一个线程实例在运行过程当中要执行的代码，即程序当中除了主线程之外的所有线程，它们执行的时候的入口就是该线程对象中的`run()`方法，这个`run()`方法是执行线程的一个入口，执行一个线程的时候就是执行`run()`方法当中的代码；

### 定义一个线程：
#### 第一种方式：  
继承`java.lang.Thread`类  
首先，定义`Thread`的子类，即我们需要定义一个类，而这个类继承自`java.lang.Thread`类；  
然后，在这个类当中需要重写一个方法，就是父类的`run()`方法，在`run`方法中实现线程需要完成的功能。  
使用`new`关键字创建一个`Thread`的子类的对象。  
为了完成特定的功能，就需要调用这个对象的start方法来启动该线程。  
这样就完成了一个线程的定义、创建和启动；

##### 示例：
- 线程类：
```java
public class MyThread extends Thread {
//初始化一个整型变量
private int count = 0;

public void run() {
//这里是线程启动以后要执行的代码--->>
while(count < 100) {
 count++;
}
System.out.println("count的值是" + count);
//<<--
 }
}
```
- 测试类：
```java
public class TestMyThread {
 public static void main(String[] args) {
//实例化线程对象
MyThread mt = new MyThread();
//启动线程
mt.start();
  }
}
```
定义线程的时候，这个线程的功能都是在`run`当中方法来实现的，`run`方法，又被标识为`public`，为什么不使用`run`方法，而使用`start`方法来启动。  
线程总是有操作系统来占用和管理的。  
一个新的线程，只能由操作系统来创建和启动，当我们调用一个`Thread`对象的`start`方法的时候，它就会调用一个本地的代码；  
这个本地的代码，就会使系统初始化一个新的线程，由这个新的线程来执行`Thread`对象的`run`方法，所以如果我们直接调用`run`方法的话，那么这个run方法就和其他对象当中的一般方法没有什么区别，也达不到我们预期的效果。  
**注意**：我们总是应该通过`start`方法来启动一个线程，而不是直接调用`run`方法。
##### start方法的作用：
该方法会使操作系统初始化一个新的线程,
之后，由这个新的线程来执行线程对象的`run`方法；  
##### 继承Thread类存在的问题：
线程类不能继承其他类；

#### 第二种方式：
##### 实现java.lang.Runnable接口：
1.定义一个类，这个类需要实现Runnable接口，  
2.在这个类当中需要实现Runnable接口当中的run方法,在run方法中我们实现线程需要完成的功能。  
3.实例化Runnable接口实现类的对象；  
4.将Runnable接口实现类的对象作为Thread类构造方法的参数，来实例化一个Thread类的线程对象；  
5.调用这个线程对象的start方法来启动这个线程。  
##### Runnable 接口的优点：
1.Runnable接口的实现类可以实现其他接口，也可以继承其他类；  
2.Runnable接口实现类的对象的资源可以被多个线程共享；
##### Runnable接口的缺点：
开发方式有点复杂；

##### 示例：
- 线程类：
```java
public class MyRunnable implements Runnable {
//初始化一个整型变量
private int count = 0;


public void run() {
//这里是线程启动以后要执行的代码--->>
while (count <100) {
count ++;
}
System.out.println("count的值是： "+count);
//<<--
   }
}
```
- 测试类：
```java
public class TestMyRunnable {
public static void main(String[] args) {
//使用MyRunnable对象作为参数创建一个线程对象
Thread thread = new Thread(new MyRunnable());
//启动此线程
thread.start();
   }
}
```
##### 示例：
Runnable接口实现类的对象的资源可以被多个线程共享；
- 线程类：
```java
public class MyRunnable implements Runnable {
//初始化一个整型变量
private int count = 0;


public void run() {
//这里是线程启动以后要执行的代码--->>
 
count ++;

System.out.println("count的值是： "+count);
//<<--
   }
}
```
- 测试类：
```java
public class TestMyRunnable {
public static void main(String[] args) {
//使用MyRunnable对象作为参数创建一个线程对象
MyRunnable mr = new MyRunnable();
Thread thread1 = new Thread(mr);
Thread thread2 = new Thread(mr);
//启动线程
System.out.println("线程1已启动");
thread1.start();
System.out.println("线程2已启动");
thread2.start();
   }
}
```
输出结果：  
线程1已启动  
count的值是： 1  
count的值是： 2

##### 两种创建方式的比较：
继承`Thread`类：
##### 优点：
- 编写简单；
- 可以使用this关键字直接访问当前线程；
##### 缺点：
无法继承其他的类；

##### 实现Runnable接口：
##### 优点：
- 可以继承其他的类；
- 多个线程之间可以使用同一个`Runnable`对象；  
##### 缺点：
编程方式稍微复杂，如需访问当前线程，则需调用`Thread`类的`currentThread()`方法；

##### 线程的状态分为：
1.新生（new）状态  
用`new`关键字创建了一个线程，但是还没有调用它的`start`方法。  
2.可运行（Runnable）状态  
调用了线程对象的start方法，这个对象可能正在运行，也可能尚未运行。  
3.阻塞状态（Waiting/blocking)  
被阻塞状态是一种“不可运行”的状态，而处于这种状态的线程在得到一个特定的事件之后，可能会返回到可运行状态；  
##### 导致一个线程被阻塞的原因有：
- 调用`Thread`类的静态方法`sleep()`方法；
- 如果一个线程需要用到一个读写操作的结果，而这个读写操作的结果尚未完成，这个线程将被阻塞。
- 如果一个线程的执行需要得到一个对象的锁，而这个对象的锁正被别的线程占用，这个线程将被阻塞。他需要等到这个对象的锁被其他的线程释放以后，才能继续执行。
- 当一个线程对象执行了`suspend`方法而被挂起时，这个线程将被阻塞。但是这个`suspend`方法是一个很危险的方法，这个方法容易导致死锁，它已经被`JDK`列为过期方法，以后不再使用它。  

4.死亡(Dead)状态  
当一个线程的`run()`方法运行完毕以后，或者这个线程在运行过程中出现没有被捕获的异常时，这个线程就会进入死亡状态，处于状态的死亡线程可能不会马上释放占用的内存资源，但是这个时候它也不再是一个独立的可执行单元。  
也就是说，如果我们尝试在一个已经死亡的线程上调用`start()`方法，就会得到一个异常信息，也就是说一个线程对象，它只能运行一次，当它运行完毕以后，我们就不能再用这个线程对象调用它的`start`方法，让它重新执行；

#### 线程的优先级：
默认情况下，一个线程继承其父类（父线程）的优先级；
- 一个线程的父线程：
就是启动它的那个线程，我们称之为它的父线程；  
当一个线程调度程序选择一个线程时，会优先考虑优先级别比较高的线程。  
在`Java`程序当中，优先级表示为一个整数值；  
这个值的大小就表示了这个线程在与其他的线程竞争处理器资源的时候，得到执行的机会的多少。  
优先级别越高，执行的机会就越大，反之，执行的机会就越小；    
`说明：线程的优先级和线程执行的效率是没有必然的联系的；`  
即，如果只有一个线程正在运行，那么高优先级的线程未必会在效率上高于低优先级的线程；
它仅仅是决定了CPU如何在线程间进行切换。  
##### 切换的原则：
首先，当一个线程自愿地释放控制时，它会通过显式的放弃、睡眠或者阻塞来完成，在这种情况下，所有线程均接受线程调度器的检查，而且优先级别高的线程会将优先执行。  
另外一种情况，当一个线程可以被一个高优先级的线程抢占资源的时候：  
在这种情况下CPU会始终处理高优先级线程，而低优先级的线程将不受到处理，我们称之为抢占式多任务；  
高优先级的线程可以抢占低优先级线程的CPU资源；

##### 更改线程的优先级：
- setPriority()方法：
语法：  
线程对象`.setPriority`(优先级的值);  
示例：  
`myThread.setPriority(3);`

##### 注意：
- 线程的优先级的范围可能根据操作系统的不同而不同；
- 通常情况下，优先级的值最大为10，最小为1，默认为5；


#### 线程的调度：
- join()方法：
它是在`Thread`类当中定义的非静态方法，  
作用：阻塞指定的线程等到另一个线程完成以后再继续执行；  
有两个线程A和B，如果在A的run()方法中，调用b.join();  
则，把A加入到B的末尾，等B执行完以后A才能继续执行，而在B执行完之前A一直处于被阻塞的状态；  
```java
public class JoinTest extends Thread {
public JoinTest(String name) {
    super(name);
}
public void run() {
for(int i=0;i<5;i++) {
  System.out.println(getName()+""+i);
  }
}

public static void main(String[] args) {
for(int i=0;i<10;i++) {
if(i == 5) {
 JoinTest tempjt = new JoinTest("半路加入的线程");
 try {
  tempjt.start();
  tempjt.join();
}catch(InterruptedException e) {
 e.printStackTrace();
 }
}
 System.out.println(Thread.currentThread().getName()+""+i);
    }
   }
}
```
定义了一个`main`方法，就是说，这个类除了可以作为一个线程类之外，还可以作为一个`Java`程序进行运行，而这个`main`方法就是当前程序的主线程；    
`tempjt.join()`：把当前代码所在的线程，即主线程，加入到`tempjt`这个线程后面，等`tempjt`运行完了以后，主线程才能够继续运行，而在`tempjt执行完之前，主线程是不能够继续执行的，它只能处于被阻塞的状态；

运行结果：  
```
main0
main1
main2
main3
main4
半路加入的线程0
半路加入的线程1
半路加入的线程2
半路加入的线程3
半路加入的线程4
main5
main6
main7
main8
main9
```
**注意**：在`tempjt`线程执行完以后，主线程又恢复执行，是接着刚才的执行状态继续执行，而不是从头开始重新执行。   


##### sleep()方法：
它是在`Thread`类中定义的静态方法。即，可以直接通过`Thread`类名来访问这个方法，而不用线程对象。  
语法：  
`Thread.sleep(long milis);`    
给`sleep`方法指定一个长整型的参数，可以让当前正在运行的线程在指定的毫秒数内停止执行并转入被阻塞的状态；这个时候其他正在等待运行的线程就会有机会获得处理器，从而得到执行；  
如果这个时候，没有其他正在等待运行的线程，当前线程仍然会停止执行；  
示例：  
```java
public class TestSleep {
public static void main(String[] args) {
System.out.println("Wait");
//让主线程等待5s
Wait.bySec(5);
//提示恢复执行
System.out.println("start");
  }
}

class Wait {
 public static void bySec(long s) {
  //sleep s个1秒
for(int i=0;i<s;i++) {
 System.out.println(i+1+"秒");
try {
  //sleep1秒
   Thread.sleep(1000);
 } catch(InterruptedException e) {
   e.printStackTrace();
      }
    }
   }
}
```
运行结果：    
Wait  
1秒    
2秒   
3秒   
4秒   
5秒   
start   

##### yield()方法：
它是在Thread类中定义的静态方法；  
语法：  
`Thread.yield();`  
这个方法让当前线程转入可运行的状态。即，调用这个方法，让当前线程转入可运行状态之后，这个当前线程仍然可以与其他的等待执行的线程竞争处理器资源；  
当调用了`yield()`方法之后，这个线程被暂时停止运行，而只有优先级与当前线程相同，或者优先级高于当前线程的线程，才可能获得执行的机会；  
如果调用了`yield()`方法之后，没有其他正在等待执行的线程，那么当前线程就会马上恢复执行，而不会强制等待。  
示例：  
```java
public class YeildTest {
public static void main(String[] args) {
MyNewThread mnt = new MyNewThread();
TheThread mt = new TheThread();
mt.start();
mnt.start();
  }
}

class TheThread extends Thread {
 public void run() {
  for(int i =0;i<5;i++) {
  System.out.println("第一个线程的第"+(i+1)+"次运行");
  Thread.yield();
   }
  }
}

class MyNewThread extends Thread {
 public void run() {
  for(int i =0;i<5;i++) {
  System.out.println("第二个线程的第"+(i+1)+"次运行");
  Thread.yield();
   }
  }
}
```
线程一和线程二是交替执行的；  
运行结果：  
```
第一个线程的第1次运行
第二个线程的第1次运行
第一个线程的第2次运行
第一个线程的第3次运行
第二个线程的第2次运行
第一个线程的第4次运行
第一个线程的第5次运行
第二个线程的第3次运行
第二个线程的第4次运行
第二个线程的第5次运行
```
##### sleep()方法与yield()方法的比较：
`sleep()`方法使当前线程转入被阻塞的状态，而`yield()`方法使当前线程转入可运行状态；  
`sleep()`方法总是强制当前线程停止执行，而`yield()`方法不一定；  
`sleep()`方法可以使其他等待运行的线程有同样的执行机会；  
而`yield()`方法只使相同或者更高优先级的线程获得执行机会；   
使用`sleep()`方法时需要捕获异常而`yield()`方法无需捕获异常；  
由于`sleep`方法是将当前线程停止执行指定的时间，而且在这个指定的时间内这个线程一直处于被阻塞的状态，也就是说经过这段时间之后这个线程还是可以恢复执行的。  
那么如果在这段时间内，我们已经调用了这个线程的`interrupt`方法，也就是给这个线程打上了一个中断的标记，那么当它恢复执行以后再调用`sleep`方法的时候，`sleep`方法就会检测到这个线程已经打上了中断标记了，所以，这个时候程序就会抛出`InterruptedException`异常。  
但是`yield`方法则不同。它只是将当前线程转入可运行状态，它并不会去检测此线程是否已经设置了中断标志，也就不会抛出`InterruptedException`异常。 
也就是说，我们在使用`sleep`方法的时候，需要用到`try{}catch{}`块来捕捉可能抛出的`InterruptionException`异常，而使用`yield`方法的时候，则不用捕获异常；

##### setDaemon()方法：
语法：  
线程对象`.setDaemon(boolean on）`；    

当我们使用这个方法让一个线程变为后台线程的时候，只能在线程启动之前讲此线程设为后台线程，而不能在启动之后。

通过给`setDaemon()`方法传递一个`boolean`型的参数，就可以指定一个线程，是否为后台线程。这个后台线程也称为守护线程，  
后台线程就是一个在后台运行的线程，它从属于创建它的线程。  
因此，当创建后台线程的线程结束时，这个后台线程也将随之消亡。在所有的线程当中，除了后台线程之外，其他的所有线程都统称为用户线程。这些用户线程拥有自己的生命周期，而不依赖于创建它的父线程。在创建它的父线程结束之后，用户线程还能继续运行。我们创建一个线程的时候，包括主线程都是用户线程；  
另外，在我们使用`setDaemon()`方法的时候，应该注意：  
当我们使用这个方法让一个线程变为后台线程的时候，只能在线程启动之前将此线程设为后台线程，而不能在启动之后。  
如果我们试图在线程运行之后再将它设为后台线程的话，那么就会引起异常。  
另外，由线程创建的线程默认为后台线程。  
```java
public class DaemonTest extends Thread {
public void run() {
while(true) {
System.out.println(getName());
  }
}

public static void main(String[] args) {
DaemonTest dt = new DaemonTest();
dt.setDaemon(true);
dt.setName("后台线程");
dt.start();
for(int i=0;i<10;i++) {
System.out.println(Thread.currentThread().getName()+" " +i);
    }
  }
}
```
创建对象dt之后在这个线程运行之前将该线程设置为一个后台线程

##### 线程同步的必要性：
如果使用两个不同的线程同时访问同一个对象，而这两个线程都会修改该对象的状态，即，如果两个不同的线程同时调用同一个对象的`setter`方法来设置这个对象的状态，而这个对象很可能被整个程序的其他部分引用；  

当我们用两个或者更多的线程共享一个公有资源的时候，例如两个线程同时读写同一个文件，或者两个线程同时操作数据库中的同一个数据时，这个时候就需要我们确保在一个线程使用这个资源的时候，其他的线程就不能修改这个资源。  
我们管理这种情况的一种办法就是对所有涉及的线程采取同步处理；


##### 如何在多个线程之间进行同步控制：
在`Java`语言当中，线程之间的同步是用"锁"来实现的。  
在`Java`语言当中，每个对象都有一个内置的锁，  
这个锁，在平时不会起到任何作用，只有在这个对象中存在着同步代码块的时候，这个锁才会发挥作用；当我们在执行一个非静态同步方法的时候，我们就自动获得当前对象的锁，而且这个锁，只能被一个同步方法或同步代码块获得。获得当前对象的锁，我们也称之为锁住了当前对象，或者同步当前对象。   
同步处理的目的就是确保几个线程要访问同一个资源的时候，在任何一个给定的时刻只能有一个线程可以访问该资源，而其他的线程要等待这个线程使用完这个资源以后才能使用。  
即，如果线程中需要访问某个资源，而这个资源唯一的锁已经被其他的线程占用，那么这个时候当前线程就不可能再得到这个资源的锁，也就不可能再操作这个资源，直到第一个线程释放了资源的锁，它才能够继承操作。  
操作一个资源或者说操作一个对象的时候，我们都是通过某个方法中的代码实现的。因此，我们同步的目的，就是说当一个线程在利用某一段代码操作一个对象的时候，那么其他的线程就不能够同时进入这段代码可。


因此，采用同步处理来控制线程的执行有两种方式：  
1.同步方法：    
当在一个类当中，同步若干个方法的时候，可以使这个类的同一个对象，在这些方法上面，它们是互斥的,（同步一个方法可以使同一个类对象，在某些方法上是互斥的）在这个类的对象，它的所有的同步方法当中，一次只能有一个可以执行。当一个对象当前正在执行的同步方法结束以后，其他的同步方法才能执行。  
这样就可以保证在任何时刻只有一个线程可以执行该对象中被同步的方法；也就可以保证在任何时刻只有一个线程可以通过这段代码去操作共享资源，而其他的线程此时则不能再访问这个对象中的被同步方法。  
将一个方法设为同步方法：  
语法：  
`访问修饰符 synchronized 返回类型 类名{}`
或者  
`synchronized 访问修饰符 返回类型 类名{}`  
其中：访问修饰符是指`public，private，public`等；  
```java
private synchronized void makeWithdrawal(int amt) {
}
```
`synchronized`的意思就是说，当一个线程已经在执行此方法的时候，这个线程就得到了当前对象也就是`this`关键字指向的对象的锁，当一个线程获得这个锁以后，其他的线程就不能够再获得这个锁了，而是在占用这个锁的线程执行完这个方法以后，它才会释放这个锁，在它释放这个锁之前其他的线程不能得到这个锁，因此也就无法同时执行此对象的同一个方法，这样就完成了对这个方法的同步；  
那么接下来所有线程访问此方法所在的对象时，也就会按照同步的方式去执行了，也就是说不可能有两个线程同时执行同一个对象的同一个方法。

**注意**：  
- 第一点：两个线程不能同时访问同一个对象中标注为同步的方法，但是对于这个对象中没有标注`synchronized`关键字的方法是没有约束的。这些方法可以让多个线程同时访问。
- 第二点：同步一个方法对在用一个对象当中是起作用的，但是，如果是在不同的对象当中，虽然他们是同一个类，但是他们是同一个类的不同对象，那么他也起不到同步的作用。

##### 同步代码块：
这种方式可以指定哪几行代码需要在哪个对象上进行同步，
即，它可以指定程序要执行这部分被同步的代码，就需要获得哪个对象的锁，这个对象可以是任何存在的对象而不一定是`this`关键字指向的这个当前对象；  
语法：  
`synchronized（指定要收益的对象）{同步语句块}`  

#### 死锁：
当两个线程互相等待对方释放它们各自拥有的对象的锁的时候就会发生死锁。  
当程序当中发生死锁的情况的时候，程序不会给我们任何提示或者抛出任何的异常，但是这个时候所有相关的线程均处于阻塞的状态。

#### 线程间通信的必要性：
问题：  
生产者和消费者问题；  
在传统的思路当中往往是利用循环检查的方式来解决这类问题。  
这种方式往往是通过重复检查某一个特定的条件是否成立，来决定线程的推进顺序。  
这种方式不值得推荐；  
当一个线程在继续执行前，如果它需要等待一个条件才可以继续执行时，仅仅有`synchronized`关键字是远远不够的。    
因为虽然`synchronized`关键字可以阻止并发更新同一个共享资源，并且实现了同步，但是它并不能用于实现不同线程之间的消息传递，即通信。而我们在处理此类问题的时候又必须要遵循一种原则。   
那就是：多个线程之间要实现互相通信。  
#### 线程间通信的实现：  
这三个方法都是在`Object`类中定义的。在`Java`当中的每个类都默认的拥有这三个方法。  
注意：这三个方法都只能在同步方法或者同步代码块中使用，否则的话就会抛出异常。  
##### wait()方法
调用`wait()`方法以后，会挂起当前的这个线程，并且释放共享资源的锁；  
`wait`方法需要在同步方法或者同步代码块中调用，那么既然是同步方法或同步代码块，就需要一个对象的锁，在这里释放的就是这个共享资源的锁。  
同时，调用`了wait()`方法以后，当前的线程会从可运行状态，转入到阻塞状态。直到调用了`wait`方法所属的那个对象的`notify()`方法或者`notifyAll()`方法为止。
##### notify()方法
调用`notify()`方法可以唤醒因为调用`wait`方法而被挂起的那个线程。并使这个线程退出阻塞状态而进入可运行状态。 
如果这个时候没有正在等待的线程，这个notify()方法就什么也不做，即它不起任何作用。  
##### notifyAll()方法
调用了`notifyAll()`方法之后，可以使所有因为调用`wait`方法而被挂起的线程都重新启动，但是这个时候有一个条件，那就是`wait()`方法和`notifyAll()`方法要属于同一个对象。这个时候，优先级别最高的那个线程就最先执行。  
示例：  
把生产者和消费者看做是两个线程。操作当中的产品可以看做是共享的资源。  
产品类：  
```java
class SharedDate {
private char c;
private boolean isProduced = false; //信号量
//同步方法putShareChar()
public synchronized void putShareChar (char c) {
//如果产品还未消费，则生产者等待
if(isProduced) {
 try {
System.out.println("消费者还未消费，因此生产者停止生产");
wait(); //生产者等待
}catch(InterruptedException e) {
 e.printStackTrace();
   }
}
this.c = c;
isProduced = true; //标记已经生产
notify();  //通知消费者已经生产，可以消费
System.out.println("生产了产品"+c+"通知消费者消费...");
}
//同步方法getShareChar()
public synchronized char getShareChar() {
//如果产品还未生产，则消费者等待
if(!isProduced) {
 try {
  System.out.println("生产者还未生产，因此消费者停止消费");
wait();  //消费者等待
}catch(InterruptedException e) {
 e.printStackTrace();
   }
}
isProduced = false; //标记已经消费
notify(); //通知需要生产
System.out.println("消费者消费了产品"+ c+"通知生产者生产...");
 return this.c;
     }
}
//生产者线程
class Producer extends Thread {
private SharedDate s;
Producer(SharedDate s) {
 this.s = s;
}
public void run() {
for(char ch = 'A';ch<='D';ch++) {
 try {
 Thread.sleep(int)(Math.random()*3000));  //取一个0-1范围内的随机数，用这样的随机数乘以3000，就可以得到一个随机的时间间隔，而这个时间间隔是在1秒到3秒之间。
即每隔一秒到三秒之间的间隔就会生成一个产品。
}catch(InterruptedException e) {
e.printStackTrace();
   }
s.putShareChar(ch); //将产品放入仓库
        }
    }
  }
}

//消费者线程
class Consumer extends Thread {
private SharedDate s;
Consumer(SharedDate s) {
 this.s = s;
 }
public void run() {
char ch;
do{
 try{
 Thread.sleep(int)(Math.random()*3000));
}catch(InterruptedException e) {
 e.printStackTrace();
 }
ch  = s.getSharChar();  //从仓库中取出产品
} while(ch!='D');
  }
 }
}

//每隔1-3秒，就去仓库中取出一个产品。直到取到D为止。

//测试类
class CommunicationDemo {
public static void main(String[] args) {
//共享同一个共享资源
SharedDate s = new SharedDate();
//消费者线程
new Consumer(s).start();
//生产者线程
new Producer(s).start();
  }
}
```
**注意：在创建两个线程的时候，一定要使用同一个共享资源对象，
否则，就达不到同步的目的。**



## 总结：
### 创建线程：
1.继承`Thread`类；  

2.实现`Runnable`接口；
- 步骤：  
1.实现`Runnable`接口  
2.实现`run`方法  
3.实例化`Runnable`接口实现类的对象  
4.将`Runnable`接口实现类的对象作为`Thread`类构造方法的参数，来实例化一个`Thread`类的线程对象  
5.调用当前`Thread`类的线程对象的`start`方法；  

#### join()方法的使用：
- join()方法的特点：
1.当前线程会被挂起，让`join`进来的线程执行；  
2.join进来的线程没有执行完毕，会一直阻塞当前线程；  

`main`方法启动时，就会创建当前`JAVA`程序的主线程；

#### sleep()方法的作用是：
- 将当前线程挂起（当前的线程暂停执行），并阻塞指定的时间；
- 当前线程挂起后，就会释放系统资源；

##### yield()方法：

##### setDaemon()方法：


### 更改线程的优先级：
#### setPriority()方法：
语法： 
`线程对象.setPriority(优先级的值);`
示例：  
`myThread.setPriority(3);`



#### 采用同步处理来控制线程的执行有两种方式：
##### 同步方法：
语法：    
`访问修饰符 synchronized 返回类型 类名{}`  
或者   
`synchronized 访问修饰符 返回类型 类名{}`  
如果一个资源被多个线程使用，不上锁会造成数据读取严重错误；  
如果想让当前资源被一个线程使用时，不会受到其他线程影响，应该给当前的资源上锁；  
在`Java`中，使用`sychronized`关键字保证数据同步。  

#### 同步代码块：
语法：   
`synchronized（指定要收益的对象）{同步语句块}`

#### 如何找到收益对象：
通过查看需要同步的代码，找到这样一个对象；  
这个对象存在被多个线程使用的情况；  
#### 同步方法和同步代码块的区别： 
- 同步方法，是通过this关键字找到当前的对象，将当前对象上锁；
- 同步代码块，可以指定任意一个对象；
- 同步代码块，可以控制的更具体；


### 线程间通信的必要性
wait()方法    
notify()方法  
notify()方法  


